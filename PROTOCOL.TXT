-------------------------------------------------- PROTOCOL DOCUMENT ---------------------------------------------------


------------------------------------------------------ BOOTING UP ------------------------------------------------------

  Server starts up, loads (password-protected via KeyStore) or generates its keypair (RSA) used for signing
(SHA3-512withRSA). The server's public signing key is to be known ahead-of-time by clients.

  Client starts up, loads (password-protected via KeyStore) or generates its keypair (RSA) used for signing
(SHA3-512withRSA).

------------------------------------------- CLIENT/SERVER PROTOCOL HANDSHAKE -------------------------------------------

  Server listens for TCP connections, client connects to the server and sends the magic protocol number (uint16) and
protocol version (uint16), server accepts the connection and checks for the received magic protocol number and protocol
version:
  * If the magic number does not match the connection is immediately closed.
  * Otherwise if the protocol version does not match the server sends a accept_status message with success = false and
    an appropriately descriptive deny_reason field, then it closes the connection.
  * Otherwise the server sends a accept_status message with success = true and no deny_reason field
    (NOT an empty string) and awaits for the client to send a hello message.

------------------------------------------ ENCRYPTION HANDSHAKE BETWEEN PEERS ------------------------------------------

  Party 1 (Alice) generates a fresh keypair (X25519) used for generating a secret key (256-bit AES) and a random nonce
as it wishes to perform a handshake with Party 2 (Bob) and sends a hello message with the generated public key for the
secret key agreement procedure, its signature, the random nonce, and its signature.

  Bob generates a fresh keypair (X25519) used for generating a secret key (256-bit AES) and a random nonce as it wishes
to accept and perform the handshake with Alice, receives Bob's hello message and sends back a hello message with the
generated public key for the secret agreement procedure, its signature, the random nonce, and its signature.

  Once that happens, both peers via KeyAgreement (X25519) using their private key from the freshly-generated keypair and
the peer's public key generate the shared secret, they also generate a hash (SHA3-512) of all the messages sent until
now (Alice's hello, Bob's hello), then a key derivation function (KDF, HKDF-SHA512) is used with the shared secret as
initial keying material (IKM), the messages hash as salt, and the nonces as info for generating:
  * a local key, using the string "{} key" as KDF info where "{}" is replaced with the hexdump of the local nonce
  * a local IV, using the string "{} iv" as KDF info where "{}" is replaced with the hexdump of the local nonce
  * a remote key, using the string "{} key" as KDF info where "{}" is replaced with the hexdump of the remote nonce
  * a remote IV, using the string "{} iv" as KDF info where "{}" is replaced with the hexdump of the remote nonce
Those keys and IVs are used to create ciphers (AES_256):
  * a local cipher used to decrypt incoming messages
  * a remote cipher used to encrypt outgoing messages

  Every future message that is sent and received from either party is encrypted and decrypted using the corresponding
cipher. Every future message that is sent to the other party is to be wrapped in a request message with a
unique ID (uint64) for that message, and every request message that requires a response is to be wrapped in a response
message with the same ID. Note that the ID is not required to be globally unique, it is only to be unique between the
current communication session between the two peers, as the IDs are entirely ephemeral to the *direction* of the current
session (that is, if Alice sends Bob a request message with ID 123, Bob is allowed to send its own unrelated request
message with ID 123).
