-------------------------------------------------- PROTOCOL DOCUMENT ---------------------------------------------------


------------------------------------------------------ BOOTING UP ------------------------------------------------------

  Server starts up, loads (password-protected using PBEWithHmacSHA512AndAES_256) or generates its keypair (RSA) used for
signing (SHA3-512withRSA). The server's public signing key is to be known ahead-of-time by clients.

  Client starts up, loads (password-protected using PBEWithHmacSHA512AndAES_256) or generates its keypair (RSA) used for
signing (SHA3-512withRSA).

------------------------------------------- CLIENT/SERVER PROTOCOL HANDSHAKE -------------------------------------------

  Magic protocol number: 0xea68
  Current protocol version: 0

  Server listens for TCP connections, client connects to the server and sends the magic protocol number
(uint16 in network byte order) and protocol version (uint16 in network byte order), server accepts the connection and
checks for the received magic protocol number and protocol version:
  * If the magic number does not match the connection is immediately closed.
  * Otherwise if the protocol version does not match the server sends a AcceptStatus message with an appropriately
    descriptive deny_reason field, then it closes the connection.
  * Otherwise the server sends a AcceptStatus message with no deny_reason field (NOT an empty string). Proceed with
    Encryption Handshake Between Peers where Party 1 = client and Party 2 = server.

------------------------------------------ ENCRYPTION HANDSHAKE BETWEEN PEERS ------------------------------------------

  Party 1 (Alice) generates a fresh keypair (X25519) used for generating a shared secret (256-bit AES, explained later
on the key agreement procedure) and a random nonce (byte[16]) as it wishes to perform a handshake with Party 2 (Bob) and
sends a Hello message with the generated public key for the secret key agreement procedure, its signature, the random
nonce, and its signature.

  Bob generates a fresh keypair (X25519) used for generating a shared secret (256-bit AES, explained later on the key
agreement procedure) and a random nonce (byte[16]) as it wishes to accept and perform the handshake with Alice, receives
Alice's Hello message and sends back a Hello message with the generated public key for the secret agreement procedure,
its signature, the random nonce, and its signature.

  If Bob is the server, then Alice must verify the provided signatures with the known server's public signing key.

  Once that happens, both peers via KeyAgreement (X25519) using their private key from the freshly-generated keypair and
the peer's public key generate the shared secret, they also generate a hash (SHA3-512) of all the messages sent until
now:
  * Alice's public key exchange key
  * Alice's public key exchange key signature
  * Alice's public nonce
  * Alice's public nonce signature
  * Bob's public key exchange key
  * Bob's public key exchange key signature
  * Bob's public nonce
  * Bob's public nonce signature
Then a key derivation function (KDF, HKDF-SHA512) is used with the shared secret as initial keying material (IKM), the
messages hash as salt, and the nonces as info for generating:
  * a local 256-bit AES key, using the string "{} key" as KDF info where "{}" is replaced with the hexdump of the local nonce
  * a local 128-bit IV, using the string "{} iv" as KDF info where "{}" is replaced with the hexdump of the local nonce
  * a remote 256-bit AES key, using the string "{} key" as KDF info where "{}" is replaced with the hexdump of the remote nonce
  * a remote 128-bit IV, using the string "{} iv" as KDF info where "{}" is replaced with the hexdump of the remote nonce
Those keys and IVs are used to create ciphers (AES_256):
  * a local cipher used to decrypt incoming messages
  * a remote cipher used to encrypt outgoing messages

  Every future message that is sent and received from either party is encrypted and decrypted using the corresponding
cipher. Every future message that is sent to the other party is to be wrapped in a Request message with a unique ID
(uint64) for that message, and every request that requires a response is to be wrapped in a Response message with the
same ID. Note that the ID is not required to be globally unique, it is only to be unique in the current communication
session between the two peers, as the IDs are entirely ephemeral to the *direction* of the current session (that is, if
Alice sends Bob a request message with ID 123, Bob is allowed to send its own unrelated request
message with ID 123).
  If Bob is the server, the client must disconnect immediately upon receiving a Disconnect message (wrapped in a Request
message) without sending a Response message back and vice-versa.
  If Bob is the server, the client must send a Keepalive message (wrapped in a Request message) every few seconds (if no
other messages have been sent) as the server has a read/write timeout of 10 seconds.
