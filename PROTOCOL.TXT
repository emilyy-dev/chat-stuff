-------------------------------------------------- PROTOCOL DOCUMENT ---------------------------------------------------


------------------------------------------------------ BOOTING UP ------------------------------------------------------

  Server starts up, loads (password-protected using PBEWithHmacSHA512AndAES_256) or generates its keypair (RSA) used for
signing (SHA3-512withRSA). The server's public signing key is to be known ahead-of-time by clients.

  Client starts up, loads (password-protected using PBEWithHmacSHA512AndAES_256) or generates its keypair (RSA) used for
signing (SHA3-512withRSA).

------------------------------------------- CLIENT/SERVER PROTOCOL HANDSHAKE -------------------------------------------

  Magic protocol number: 0xea68
  Current protocol version: 0

  Server listens for TCP connections, client connects to the server and sends the magic protocol number
(uint16 in network byte order) and protocol version (uint16 in network byte order), server accepts the connection and
checks for the received magic protocol number and protocol version:
  * If the magic number does not match the connection is immediately closed.
  * Otherwise if the protocol version does not match the server sends a AcceptStatus message with an appropriately
    descriptive deny_reason field, then it closes the connection.
  * Otherwise the server sends a AcceptStatus message with no deny_reason field (NOT an empty string). Proceed with
    Encryption Handshake Between Peers where Party 1 = client and Party 2 = server.

------------------------------------------ ENCRYPTION HANDSHAKE BETWEEN PEERS ------------------------------------------

  Party 1 (Alice) generates a fresh keypair (X25519) used for generating a shared secret (256-bit AES, explained later
on the key agreement procedure) and a random nonce (byte[16]) as it wishes to perform a handshake with Party 2 (Bob) and
sends a Hello message with the generated public key for the secret key agreement procedure, its signature, the random
nonce, and its signature.

  Bob generates a fresh keypair (X25519) used for generating a shared secret (256-bit AES, explained later on the key
agreement procedure) and a random nonce (byte[16]) as it wishes to accept and perform the handshake with Alice, receives
Alice's Hello message and sends back a Hello message with the generated public key for the secret agreement procedure,
its signature, the random nonce, and its signature.

  If Bob is the server, then Alice must verify the provided signatures with the known server's public signing key.

  Once that happens, both peers via KeyAgreement (X25519) using their private key from the freshly-generated keypair and
the peer's public key generate the shared secret, they also generate a hash (SHA3-512) of all the messages sent until
now:
  * Alice's public key exchange key
  * Alice's public key exchange key signature
  * Alice's public nonce
  * Alice's public nonce signature
  * Bob's public key exchange key
  * Bob's public key exchange key signature
  * Bob's public nonce
  * Bob's public nonce signature

Then a key derivation function (KDF, HKDF-SHA512) is used with the shared secret as initial keying material (IKM), the
messages hash as salt, and the nonces as info for generating:
  * a local 256-bit AES key, using the string "{} key" as KDF info where "{}" is replaced with the hexdump of the local nonce
  * a local 128-bit IV, using the string "{} iv" as KDF info where "{}" is replaced with the hexdump of the local nonce
  * a remote 256-bit AES key, using the string "{} key" as KDF info where "{}" is replaced with the hexdump of the remote nonce
  * a remote 128-bit IV, using the string "{} iv" as KDF info where "{}" is replaced with the hexdump of the remote nonce

Those keys and IVs are used to create ciphers (AES_256):
  * a local cipher used to decrypt incoming messages
  * a remote cipher used to encrypt outgoing messages

  Every future message that is sent and received from either party is encrypted and decrypted using the corresponding
cipher. Every future message that is sent to the other party is to be wrapped in a Request message with a unique ID
(uint64) for that message, and every request that has a specific response is to be wrapped in a Response message
with the same ID. Note that the ID is not required to be globally unique, it is only to be unique in the current
communication session between the two peers, as the IDs are entirely ephemeral to the *direction* of the current session
(that is, if Alice sends Bob a request message with ID 123, Bob is allowed to send its own unrelated request message
with ID 123). Requests that do not have a specific response are to be responded with a Response message with the same ID
and no message field set. Requests that have been responded to by a corresponding Response message can free their ID to
be reused in future requests. IDs are not required to be sequential but is recommended.

---------------------------------------------- CLIENT/SERVER CONSTRAINTS -----------------------------------------------

  * The client must disconnect immediately upon receiving a Disconnect message without sending a Response message back
and vice-versa.
  * The client must send a Keepalive message every few seconds (if no other messages have been sent) as the server has a
read/write timeout of 10 seconds.

------------------------------------------------ CLIENT/SERVER PROTOCOL ------------------------------------------------

TODO: this section, when user registration and user authentication need to be performed and future stuffs

-------------------------------------------------- USER REGISTRATION ---------------------------------------------------

  When a client desires to register as a new user with the server, it shall send a RegisterRequest message with the
desired username and the client's public signing key. The server then retroactively verifies the signatures sent in the
initial handshake message with the received signing key:
  * If either signature cannot be verified the server sends a Disconnect message with an appropriate reason and closes
    the connection.
  * Otherwise the server searches for the username's availability in its storage backend:
    * If the username does not have an associated public signing key then the server reserves it to become unavailable
      for future client registrations and associates with it the sent public signing key and responds with a
      RegisterResponse message with no error_message field
    * Otherwise if the username is unavailable for registration and is already associated with a public signing key, it
      responds with a RegisterResponse message with the error_message field set to an appropriately descriptive one.
      Registration failure does not constitute grounds for disconnection.

------------------------------------------------- USER AUTHENTICATION --------------------------------------------------

  When a client desires to authenticate with a username to the server, it shall send an AuthenticationRequest message
with the username to authenticate as. The server then verifies that the username has an associated public signing key
in its storage backend:
  * If it does not then the server responds with an AuthenticationResponse message with an appropriately descriptive
    error_message field.
  * Otherwise the server retroactively verifies the signatures  sent in the initial handshake message with the
    username's associated public signing key:
    * If either signature cannot be verified the server sends a Disconnect message with an appropriate reason and closes
      the connection.
    * Otherwise the client is considered authenticated with that username for the rest of the session's lifetime.
